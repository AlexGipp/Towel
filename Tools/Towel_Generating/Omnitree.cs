using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using Towel;
using static Towel.Statics;

namespace Towel_Generating
{
	internal static class Omnitree
	{
		internal static void Generate(
			int dimensions = 7)
		{
			StringBuilder file = new StringBuilder();
			file.AppendLine($@"//------------------------------------------------------------------------------");
			file.AppendLine(@"// <auto-generated>");
			file.AppendLine($@"//	This code was generated from ""{sourcefilepath()}"".");
			file.AppendLine(@"// </auto-generated>");
			file.AppendLine($@"//------------------------------------------------------------------------------");
			file.AppendLine($@"");
			file.AppendLine($@"using System;");
			file.AppendLine($@"using System.Numerics;");
			file.AppendLine($@"using static Towel.Statics;");
			file.AppendLine($@"using static Towel.DataStructures.Omnitree;");
			file.AppendLine($@"");
			file.AppendLine($@"namespace Towel.DataStructures.TEMP");
			file.AppendLine($@"{{");
			file.AppendLine($@"	#region Notes");
			file.AppendLine($@"");
			file.AppendLine($@"	// Visualizations--------------------------------------------------");
			file.AppendLine($@"	//");
			file.AppendLine($@"	// 1 Dimensional:");
			file.AppendLine($@"	//");
			file.AppendLine($@"	//  -1D |-----------|-----------| +1D");
			file.AppendLine($@"	//");
			file.AppendLine($@"	//       <--- 0 ---> <--- 1 --->");
			file.AppendLine($@"	//");
			file.AppendLine($@"	// 2 Dimensional:");
			file.AppendLine($@"	//       _____________________");
			file.AppendLine($@"	//      |          |          |  +2D");
			file.AppendLine($@"	//      |          |          |   ^");
			file.AppendLine($@"	//      |     2    |     3    |   |");
			file.AppendLine($@"	//      |          |          |   |");
			file.AppendLine($@"	//      |----------|----------|   |");
			file.AppendLine($@"	//      |          |          |   |");
			file.AppendLine($@"	//      |          |          |   |");
			file.AppendLine($@"	//      |     0    |     1    |   |");
			file.AppendLine($@"	//      |          |          |   v");
			file.AppendLine($@"	//      |__________|__________|  -2D");
			file.AppendLine($@"	//");
			file.AppendLine($@"	//       -1D <-----------> +1D ");
			file.AppendLine($@"	//");
			file.AppendLine($@"	// 3 Dimensional:");
			file.AppendLine($@"	//");
			file.AppendLine($@"	//            +3D     _____________________");
			file.AppendLine($@"	//           7       /         /          /|");
			file.AppendLine($@"	//          /       /    6    /     7    / |");
			file.AppendLine($@"	//         /       /---------/----------/  |");
			file.AppendLine($@"	//        /       /    2    /     3    /|  |");
			file.AppendLine($@"	//       L       /_________/__________/ |  |");
			file.AppendLine($@"	//    -3D       |          |          | | /|          +2D");
			file.AppendLine($@"	//              |          |          | |/ |           ^");
			file.AppendLine($@"	//              |     2    |     3    | /  |           |");
			file.AppendLine($@"	//              |          |          |/|  | <-- 5     |");
			file.AppendLine($@"	//              |----------|----------| |  |           |");
			file.AppendLine($@"	//              |          |          | |  /           |");
			file.AppendLine($@"	//              |          |          | | /            |");
			file.AppendLine($@"	//              |     0    |     1    | |/             |");
			file.AppendLine($@"	//              |          |          | /              v");
			file.AppendLine($@"	//              |__________|__________|/              -2D");
			file.AppendLine($@"	//             ");
			file.AppendLine($@"	//                   ^");
			file.AppendLine($@"	//                   |");
			file.AppendLine($@"	//                   4 (behind 0)");
			file.AppendLine($@"	//");
			file.AppendLine($@"	//               -1D <-----------> +1D");
			file.AppendLine($@"");
			file.AppendLine($@"	#endregion Notes");
			file.AppendLine($@"");
			file.AppendLine($@"	/// <summary>Contains the necessary type definitions for the various omnitree types.</summary>");
			file.AppendLine($@"	public static partial class Omnitree");
			file.AppendLine($@"	{{");
			for (int i = 1; i <= dimensions; i++)
			{
				file.AppendLine($@"		#region {i} Dimensional");
				file.AppendLine($@"");
				file.AppendLine($@"		/// <summary>Represents a {i}D vector.</summary>");
				for (int j = 1; j <= i; j++)
				{
					file.AppendLine($@"		/// <typeparam name=""A{j}"">The generic type of the {j} dimension.</typeparam>");
				}
				file.AppendLine($@"		public struct Vector<{Join(1..(i + 1), n => $"A{n}", ", ")}>");
				file.AppendLine($@"		{{");
				for (int j = 1; j <= i; j++)
				{
					file.AppendLine($@"			/// <summary>The value along axis {j}.</summary>");
					file.AppendLine($@"			public A{j} Axis{j};");
				}
				file.AppendLine($@"");
				file.AppendLine($@"			/// <summary>Returns a vector with defaulted values.</summary>");
				file.AppendLine($@"			public static Vector<{Join(1..(i + 1), n => $"A{n}", ", ")}> Default =>");
				file.AppendLine($@"				new Vector<{Join(1..(i + 1), n => $"A{n}", ", ")}>(");
				file.AppendLine($@"					{Join(1..(i + 1), n => $"default", ", ")});");
				file.AppendLine($@"");
				file.AppendLine($@"			/// <summary>A location along each axis.</summary>");
				for (int j = 1; j <= i; j++)
				{
					file.AppendLine($@"			/// <param name=""axis{j}"">The location along axis {j}.</param>");
				}
				file.AppendLine($@"			public Vector({Join(1..(i + 1), n => $"A{n} axis{n}", ", ")})");
				file.AppendLine($@"			{{");
				for (int j = 1; j <= i; j++)
				{
					file.AppendLine($@"				this.Axis{j} = axis{j};");
				}
				file.AppendLine($@"			}}");
				file.AppendLine($@"		}}");
				file.AppendLine($@"");
				file.AppendLine($@"		/// <summary>Represents a {i}D bounding box.</summary>");
				for (int j = 1; j <= i; j++)
				{
					file.AppendLine($@"		/// <typeparam name=""A{j}"">The generic type of the {j} dimension.</typeparam>");
				}
				file.AppendLine($@"		public struct Bounds<{Join(1..(i + 1), n => $"A{n}", ", ")}>");
				file.AppendLine($@"		{{");
				for (int j = 1; j <= i; j++)
				{
					file.AppendLine($@"			/// <summary>The minimum value along the {j} dimension.</summary>");
					file.AppendLine($@"			public Bound<A{j}> Min{j};");
					file.AppendLine($@"			/// <summary>The maximum value along the {j} dimension.</summary>");
					file.AppendLine($@"			public Bound<A{j}> Max{j};");
				}
				file.AppendLine($@"");
				file.AppendLine($@"			/// <summary>Extends infinitely along each axis.</summary>");
				file.AppendLine($@"			public static Bounds<{Join(1..(i + 1), n => $"A{n}", ", ")}> None =>");
				file.AppendLine($@"				new Bounds<{Join(1..(i + 1), n => $"A{n}", ", ")}>(");
				file.AppendLine($@"					{Join(1..(i + 1), n => $"Bound<A{n}>.None, Bound<A{n}>.None", ", ")});");
				file.AppendLine($@"");
				file.AppendLine($@"			/// <summary>A set of values denoting a range (or lack of range) along each axis.</summary>");
				file.AppendLine($@"			public Bounds({Join(1..(i + 1), n => $"Bound<A{n}> min{n}, Bound<A{n}> max{n}", ", ")})");
				file.AppendLine($@"			{{");
				for (int j = 1; j <= i; j++)
				{
					file.AppendLine($@"				this.Min{j} = min{j};");
					file.AppendLine($@"				this.Max{j} = max{j};");
				}
				file.AppendLine($@"			}}");
				file.AppendLine($@"		}}");
				file.AppendLine($@"");
				file.AppendLine($@"		/// <summary>Checks a node for inclusion (overlap) between two bounds.</summary>");
				file.AppendLine($@"		/// <returns>True if the spaces overlap; False if not.</returns>");
				file.AppendLine($@"		public static bool InclusionCheck<{Join(1..(i + 1), n => $"A{n}", ", ")}, {Join(1..(i + 1), n => $"Compare{n}", ", ")}>(");
				file.AppendLine($@"			Omnitree.Bounds<{Join(1..(i + 1), n => $"A{n}", ", ")}> a, Omnitree.Bounds<{Join(1..(i + 1), n => $"A{n}", ", ")}> b, {Join(1..(i + 1), n => $"Compare{n} compare{n} = default", ", ")})");
				for (int j = 1; j <= i; j++)
				{
					file.AppendLine($@"			where Compare{j} : struct, IFunc<A{j}, A{j}, CompareResult>");
				}
				file.AppendLine($@"			=>");
				for (int j = 1; j <= i; j++)
				{
					file.AppendLine($@"			a.Max{j}.Exists && b.Min{j}.Exists && compare{j}.Do(a.Max{j}.Value, b.Min{j}.Value) == CompareResult.Less    ? false :");
					file.AppendLine($@"			a.Min{j}.Exists && b.Max{j}.Exists && compare{j}.Do(a.Min{j}.Value, b.Max{j}.Value) == CompareResult.Greater ? false :");
				}
				file.AppendLine($@"			true;");
				file.AppendLine($@"");
				file.AppendLine($@"		public static bool EncapsulationCheck<{Join(1..(i + 1), n => $"A{n}", ", ")}, {Join(1..(i + 1), n => $"Compare{n}", ", ")}>(");
				file.AppendLine($@"			Omnitree.Bounds<{Join(1..(i + 1), n => $"A{n}", ", ")}> a, Omnitree.Bounds<{Join(1..(i + 1), n => $"A{n}", ", ")}> b, {Join(1..(i + 1), n => $"Compare{n} compare{n} = default", ", ")})");
				for (int j = 1; j <= i; j++)
				{
					file.AppendLine($@"			where Compare{j} : struct, IFunc<A{j}, A{j}, CompareResult>");
				}
				file.AppendLine($@"			=>");
				file.AppendLine($@"			(");
				for (int j = 1; j <= i; j++)
				{
					file.AppendLine($@"			(a.Min{j}.Exists && !b.Min{j}.Exists) {(j == i ? "" : "||")}");
				}
				file.AppendLine($@"			)");
				file.AppendLine($@"			? false :");
				file.AppendLine($@"			(");
				for (int j = 1; j <= i; j++)
				{
					file.AppendLine($@"			(a.Max{j}.Exists && !b.Max{j}.Exists) {(j == i ? "" : "||")}");
				}
				file.AppendLine($@"			)");
				file.AppendLine($@"			? false :");
				for (int j = 1; j <= i; j++)
				{
					file.AppendLine($@"			b.Min{i}.Exists && a.Min{i}.Exists && compare{i}.Do(a.Min{i}.Value, b.Min{i}.Value) != CompareResult.Less ? false :");
					file.AppendLine($@"			b.Max{i}.Exists && a.Max{i}.Exists && compare{i}.Do(a.Max{i}.Value, b.Max{i}.Value) != CompareResult.Greater ? false :");
				}
				file.AppendLine($@"			true;");
				file.AppendLine($@"");
				file.AppendLine($@"		public static bool EqualsCheck<{Join(1..(i + 1), n => $"A{n}", ", ")}, {Join(1..(i + 1), n => $"Compare{n}", ", ")}>(");
				file.AppendLine($@"			Omnitree.Vector<{Join(1..(i + 1), n => $"A{n}", ", ")}> a, Omnitree.Vector<{Join(1..(i + 1), n => $"A{n}", ", ")}> b, {Join(1..(i + 1), n => $"Compare{n} compare{n} = default", ", ")})");
				for (int j = 1; j <= i; j++)
				{
					file.AppendLine($@"			where Compare{j} : struct, IFunc<A{j}, A{j}, CompareResult>");
				}
				file.AppendLine($@"			=>");
				for (int j = 1; j <= i; j++)
				{
					file.AppendLine($@"			compare{j}.Do(a.Axis{j}, b.Axis{j}) is Equal{(j == i ? "; " : " &&")}");
				}
				file.AppendLine($@"");
				file.AppendLine($@"		/// <summary>Checks if a bounds straddles a point if the point extended as a plane along each dimension.</summary>");
				file.AppendLine($@"		/// <param name=""a"">The bounds to determine if it straddles the extended point.</param>");
				file.AppendLine($@"		/// <param name=""b"">The point representing an extended plan along each axis.</param>");
				file.AppendLine($@"		/// <returns>True if the extended point was straddled or false if not.</returns>");
				for (int j = 1; j <= i; j++)
				{
					file.AppendLine($@"		/// <typeparam name=""A{j}"">The generic type of the {j} dimension.</typeparam>");
					file.AppendLine($@"		/// <typeparam name=""Compare{j}"">The method for comparing elements along the {j} dimension.</typeparam>");
					file.AppendLine($@"		/// <param name=""compare{j}"">The method for comparing elements along the {j} dimension.</param>");
				}
				file.AppendLine($@"		public static bool StraddlesLines<{Join(1..(i + 1), n => $"A{n}", ", ")}, {Join(1..(i + 1), n => $"Compare{n}", ", ")}>(");
				file.AppendLine($@"			Omnitree.Bounds<{Join(1..(i + 1), n => $"A{n}", ", ")}> a, Omnitree.Vector<{Join(1..(i + 1), n => $"A{n}", ", ")}> b, {Join(1..(i + 1), n => $"Compare{n} compare{n} = default", ", ")})");
				for (int j = 1; j <= i; j++)
				{
					file.AppendLine($@"			where Compare{j} : struct, IFunc<A{j}, A{j}, CompareResult>");
				}
				file.AppendLine($@"			=>");
				for (int j = 1; j <= i; j++)
				{
					file.AppendLine($@"			(!a.Min{j}.Exists || (a.Min{j}.Exists && compare{j}.Do(a.Min{j}.Value, b.Axis{j}) != Greater)) &&");
					file.AppendLine($@"			(!a.Max{j}.Exists || (a.Max{j}.Exists && compare{j}.Do(a.Max{j}.Value, b.Axis{j}) != Less)) ? true :");
				}
				file.AppendLine($@"			false;");
				file.AppendLine($@"");
				file.AppendLine($@"		#endregion {i} Dimensional");
				file.AppendLine($@"");
			}
			file.AppendLine($@"	}}");
			file.AppendLine($@"");
			for (int i = 1; i <= dimensions; i++)
			{
				file.AppendLine($@"	#region {i} Dimensional");
				file.AppendLine($@"");
				file.AppendLine($@"	/// <summary>Inheritance base for {i}D omnitrees.</summary>");
				file.AppendLine($@"	/// <typeparam name=""T"">The element type of the omnitree.</typeparam>");
				for (int j = 1; j <= i; j++)
				{
					file.AppendLine($@"	/// <typeparam name=""A{j}"">The type of the {j}D axis.</typeparam>");
				}
				file.AppendLine($@"	public interface IOmnitree<T, {Join(1..(i + 1), n => $"A{n}", ", ")}, {Join(1..(i + 1), n => $"Compare{n}", ", ")}> : IOmnitree<T> {{ }}");
				file.AppendLine($@"");
				file.AppendLine($@"	#region OmnitreePoints");
				file.AppendLine($@"");
				file.AppendLine($@"	public interface IOmnitreePoints<T, {Join(1..(i + 1), n => $"A{n}", ", ")}, {Join(1..(i + 1), n => $"Compare{n}", ", ")}> : IOmnitree<T, {Join(1..(i + 1), n => $"A{n}", ", ")}, {Join(1..(i + 1), n => $"Compare{n}", ", ")}>");
				file.AppendLine($@"	{{");
				file.AppendLine($@"		// todo");
				file.AppendLine($@"	}}");
				file.AppendLine($@"");
				file.AppendLine($@"	public class OmnitreePoints<T, {Join(1..(i + 1), n => $"A{n}", ", ")}, {Join(1..(i + 1), n => $"Compare{n}", ", ")}, Locate> : IOmnitree<T, {Join(1..(i + 1), n => $"A{n}", ", ")}, {Join(1..(i + 1), n => $"Compare{n}", ", ")}>");
				for (int j = 1; j <= i; j++)
				{
					file.AppendLine($@"		where Compare{j} : struct, IFunc<A{j}, A{j}, CompareResult>");
				}
				file.AppendLine($@"		where Locate : struct, IFunc<T, {(i is 1 ? "" : "(")}{Join(1..(i + 1), n => $"A{n}", ", ")}{(i is 1 ? "" : ")")}>");
				file.AppendLine($@"	{{");
				file.AppendLine($@"		internal readonly static {(i > 30 ? "BigInteger" : "int")} ChildrenPerNode = {(i > 30 ? $"BigInteger.Pow(2, {i})" : $"{Math.Pow(2, i)}")};");
				file.AppendLine($@"");
				file.AppendLine($@"		internal Node _top;");
				file.AppendLine($@"		/// <summary>Caches the next time to calculate loads (lower count).</summary>");
				file.AppendLine($@"		internal int _naturalLogLower = 1;");
				file.AppendLine($@"		/// <summary>Caches the next time to calculate loads (upper count).</summary>");
				file.AppendLine($@"		internal int _naturalLogUpper = 1;");
				file.AppendLine($@"		/// <summary>ln(count); min = _defaultLoad.</summary>");
				file.AppendLine($@"		internal int _load = 1;");
				for (int j = 1; j <= i; j++)
				{
					file.AppendLine($@"		internal Compare{j} _compare{j};");
				}
				file.AppendLine($@"		internal Locate _locate;");



				file.AppendLine($@"	}}");
				file.AppendLine($@"");
				file.AppendLine($@"	#endregion OmnitreePoints");
				file.AppendLine($@"");
				file.AppendLine($@"	#endregion {i} Dimensional");
				file.AppendLine($@"");
			}
			file.AppendLine($@"}}");


			File.WriteAllText(Path.GetDirectoryName(sourcefilepath()) + Path.Combine("..", "..","..","Sources","Towel", "DataStructures", "Omnitree2.cs"), file.ToString());
		}
	}
}
